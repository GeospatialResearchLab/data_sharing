<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Preparing Open Data for Public Repositories</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="prepping_data_files/libs/clipboard/clipboard.min.js"></script>
<script src="prepping_data_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="prepping_data_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="prepping_data_files/libs/quarto-html/popper.min.js"></script>
<script src="prepping_data_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="prepping_data_files/libs/quarto-html/anchor.min.js"></script>
<link href="prepping_data_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="prepping_data_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="prepping_data_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="prepping_data_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="prepping_data_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Preparing Open Data for Public Repositories</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level1">
<h1>Overview</h1>
<p>Open data is only useful if it is accessible, understandable, and reusable. This mini-guide shows you how to make that happen fast.</p>
<p><strong>What you’ll learn:</strong></p>
<ul>
<li>How to choose file types that maximize long-term reuse (and what to avoid)</li>
<li>How to format quantitative and qualitative data so people and machines can work with it</li>
<li>What to include in a README, codebook, and metadata to make your dataset self-explanatory</li>
<li>How to package and organize files for a smooth repository deposit</li>
</ul>
<hr>
</section>
<section id="choosing-file-types" class="level1">
<h1>Choosing File Types</h1>
<ul>
<li>Preferred formats: CSV, TXT, JSON, GeoJSON, TIFF, PNG, XML<br>
</li>
<li>Avoid proprietary-only: .xlsx, .sav, .mdb (unless also sharing open versions)<br>
</li>
<li>Use non-lossy formats for images and raster data<br>
</li>
<li>Check community standards in your discipline</li>
</ul>
<p>The format you choose for your data is often the difference between a dataset that is usable for decades and one that quickly becomes obsolete. Open, non-proprietary formats like CSV, TXT, JSON, GeoJSON, TIFF, PNG, or XML are designed to be read by many different tools and will remain accessible long after specific software packages fade away.</p>
<p>Proprietary formats, such as Excel files (.xlsx), SPSS files (.sav), or Access databases (.mdb), can be useful in your workflow but should not be the only format you share. If you provide these, always include an open format version alongside them. For images and raster data, avoid lossy formats like JPEG where important information may be discarded. Community standards are also important. Look at what your field expects and follow those norms.</p>
<hr>
</section>
<section id="organizing-files-logically" class="level1">
<h1>Organizing Files Logically</h1>
<ul>
<li>Separate raw data, processed data, and documentation</li>
<li>Use clear, consistent folder and file naming conventions</li>
<li>Avoid burying important files deep in nested folders</li>
</ul>
<p>Good organization makes your dataset easier to navigate and reduces the chance of errors. A simple structure might include a top-level folder with subfolders for raw_data, processed_data, and documentation. Raw data should remain untouched, while processed or cleaned data goes in its own space.</p>
<p>Naming conventions also matter: choose descriptive names that include relevant details (e.g., survey_responses_2025.csv instead of data1.csv). If your project evolves over time, use version numbers or dates in file names so others can see that there have been changes and which is the most current.</p>
<p>Finally, avoid creating unnecessarily deep folder hierarchies. A user should be able to locate the key files in two or three clicks. Logical categories and clear labeling make it far easier for others (and your future self) to find what they need.</p>
<hr>
</section>
<section id="protecting-privacy-in-shared-data" class="level1">
<h1>Protecting Privacy in Shared Data</h1>
<ul>
<li>Remove or anonymize identifying information</li>
</ul>
<p>Whether your data is quantitative or qualitative, protecting privacy by removing or anonymizing personally identifying information is a universal responsibility. Even small details can reveal individual identities, so review your dataset carefully and remember to make sure that the data you release is appropriate for your IRB approval.</p>
<hr>
</section>
<section id="formatting-quantitative-data" class="level1">
<h1>Formatting Quantitative Data</h1>
<ul>
<li>Each row = observation, each column = variable (tidy data)<br>
</li>
<li>Use consistent units and formats (e.g., ISO dates)<br>
</li>
<li>Avoid merged cells or embedded formulas<br>
</li>
<li>Include variable names that are clear and human-readable</li>
<li>Clearly indicate missing or null values</li>
</ul>
<p>For quantitative data, clarity and consistency are key. One widely accepted principle is “tidy data”: each row should represent a single observation and each column should represent a variable. This makes the dataset easy to process with statistical software or scripting languages.</p>
<p>Units and formatting should always be consistent across the dataset. For instance, dates should follow a standard like ISO 8601 (YYYY-MM-DD) rather than mixing formats like “1/2/23” and “January 2, 2023.” Avoid merged cells, embedded formulas, or other formatting tricks that make data look nice in a spreadsheet but complicate machine processing.</p>
<p>Choose variable names that are descriptive and readable. Instead of <code>var1</code> or <code>tempX</code>, use names like <code>temperature_celsius</code> or <code>participant_age</code>. This reduces confusion and makes the dataset easier to interpret for both humans and software.</p>
<p>Finally, make sure you handle missing or null values consistently. Use a standard code (such as NA) rather than leaving cells blank, and explain this choice in your documentation so users know how to interpret your dataset.</p>
<hr>
</section>
<section id="formatting-qualitative-data" class="level1">
<h1>Formatting Qualitative Data</h1>
<ul>
<li>Plain text or open structured formats (e.g., TXT, JSON, XML)<br>
</li>
<li>Document coding schemes, categories, and interview protocols<br>
</li>
<li>Use UTF-8 encoding for special characters</li>
</ul>
<p>Qualitative data often takes the form of text, interviews, or coded responses. Open structured formats like plain text (.txt), JSON, or XML ensure that others can access and interpret the content.</p>
<p>When sharing coded data, include detailed documentation of the coding schemes and categories so others understand how data was interpreted. If interviews were transcribed, describe the protocol used (e.g., how pauses, tone, or interruptions are marked). Use UTF-8 encoding so that special characters, diacritics, and non-Latin scripts are preserved correctly.</p>
<hr>
</section>
<section id="documentation" class="level1">
<h1>Documentation</h1>
<ul>
<li>README file: project overview, methodology, file list, contact info<br>
</li>
<li>Codebook: variable definitions, units, missing data codes<br>
</li>
<li>Metadata: follow standards like Dublin Core, DataCite, or discipline-specific schemas<br>
</li>
<li>Provide context for reuse and reproducibility</li>
</ul>
<p>Well-prepared documentation transforms raw data into a resource that others can understand and reuse. At a minimum, include a README file that gives an overview of the project, explains the methodology, lists the files included, and provides contact information for questions. A README is the entry point to your dataset. It tells newcomers what they are looking at and why it matters.</p>
<p>For datasets with variables, include a codebook. This is where you define each variable, specify its units, and explain any special codes for missing data or categories. Without this, users can easily misinterpret your data.</p>
<p>Adding metadata further enhances discoverability and reuse. Many repositories support common schemas like Dublin Core or DataCite, while specific disciplines may have their own standards. Good metadata ensures your dataset is not just stored, but also findable through search engines and disciplinary portals.</p>
<hr>
</section>
<section id="putting-it-all-together" class="level1">
<h1>Putting it All Together</h1>
<ul>
<li>Share in open formats<br>
</li>
<li>Organize files logically</li>
<li>Format data consistently</li>
<li>Provide documentation (README + codebook)<br>
</li>
<li>Check repository guidelines and community norms</li>
</ul>
<p>Think of preparing open data as creating a care package for your future collaborators. Share files in open formats, organize them logically, format your data consistently using best practices, and provide strong documentation in the form of README files, codebooks, and metadata.</p>
<p>Finally, remember to check both your repository’s submission guidelines and the broader norms in your field. Following these ensures your dataset will not only be accepted into the repository but also recognized and reused within your research community.</p>
<hr>
</section>
<section id="pdf-download" class="level1">
<h1>PDF Download</h1>
<p><a href="handout.pdf">Download this information as a PDF handout</a></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>